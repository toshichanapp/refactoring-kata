www.DeepL.com/Translator（無料版）で翻訳しました。
https://github.com/martinsson/BugsZero-Kata/blob/master/bug-patterns.md

# バグパターン
不必要な）バグの原因となる典型的な設計上の問題を分類し、いくつかの解決策を提案しています。

これらのパターンのほとんどは、「Coupling without Cohesion」に集約されます。

いくつかのパターンは、Hidden testable code (テスト可能なコードの隠蔽)、Use of indices (インデックスの使用)、Non constrained construction (制約のない構造)など、より詳細に展開されています。

## 重複
重複している部分の1つが変化すると、他の部分も変化しなければならない。重複部分の距離が長いほど、リスクは高まります。

## プリミティブの使用
可能にする

- 重複する可能性のあるロジック
- ビジネス上の制約がない、例えば
  - 人の年齢はプラスでなければならない
  - 金利が2というのは、2％なのか200％なのか？
- 反転したパラメータが可能
- 無効な値

## 内部構造の公開
オブジェクトの内部が露出していること。
別名FeatureEnvy。以下のことが可能になります。

- ロジックが重複する可能性がある
- ロジックとデータの結束力が弱い

## 制約のない構造
- コンストラクタに含まれない必須のパラメータ
- 原始的なパラメータで、順序の入れ替えが可能
  - 型のパラメータ
  - ビルダーを使う

## 時間的結合
関数の使用は特定の順序で行わなければならず、その順序は構造（解釈/コンパイル）によって強制されない。トラップ：構造を強制する代わりに例外を使う

## テスト可能なコードの隠蔽
テストしやすいコードが、テストしにくい依存関係の呼び出しの間に隠されています。隠されたテスト可能なコードは、バグを含んでいたり、将来的にバグを発生させる可能性があります。Extract Pure Function（テストしやすい）が適用すべきリファクタリングです。

## 遅いバリデーション - 不要な例外の原因
- ex: if (myservice == null). おそらく無駄な検証
- ex: 関数内のインスタンスパラメータの検証（コンストラクタにあるべきもの
- アプリケーションのエントリーポイント（レストコール、UIフォーム、コマンドライン、メッセージバス、コンフィギュレーション）ではないバリデーション。データが他のアプリケーションから送られてくる場合は、データベースもエントリーポイントになる可能性があります。
- コールスタック内で重複している検証

## Nullフラグ
特殊な値としてnullを返すことは、クライアントコードがそのケースを処理することを保証するものではありません。実行時例外になってしまう可能性があります。代わりにNull-objectパターンを使用して、クライアントコードが心配する必要がないようにするか、Optional/Maybeを返して、クライアントコードがその可能性を認識できるようにします。

## 例外処理
よく見ると、例外処理の多くは本質的なものではなく偶発的なものです。

- 複雑さが増すが、本質的ではない複雑さも多い
- 「頂点」に向かって投げるのが良い
- 例外を処理するのではなく、例外を発生させないようにする（例：時間的結合）。

## 添字の使用
- 一つ違いのエラーがよくある
- インデックスの範囲外

## ビジネスルールとデータ構造が矛盾している
- 例: 色のセットのリスト - 重複する色
- 解決策: データを検証し、ビジネスオブジェクトを早急に構築する


